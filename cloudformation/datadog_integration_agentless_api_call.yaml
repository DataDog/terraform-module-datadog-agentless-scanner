AWSTemplateFormatVersion: 2010-09-09
Description: Datadog AWS Agentless API Call
Parameters:
  DatadogApiKey:
    Description: >-
      API key for the Datadog account
    Type: String
    NoEcho: true
    Default: ""
  DatadogAppKey:
    Description: >-
      APP key for the Datadog account
    Type: String
    NoEcho: true
    Default: ""
  DatadogSite:
    Type: String
    Default: datadoghq.com
    Description: Define your Datadog Site to send data to.
    AllowedValues:
      - datadoghq.com
      - datadoghq.eu
      - us3.datadoghq.com
      - us5.datadoghq.com
      - ap1.datadoghq.com
      - ddog-gov.com
      - datad0g.com
  Containers:
    Type: String
    AllowedValues:
      - true
      - false
    Description: >-
      Enable Container scanning.
    Default: false
  Hosts:
    Type: String
    AllowedValues:
      - true
      - false
    Description: >-
      Enable Host Vulnerability scanning.
    Default: false
  Lambdas:
    Type: String
    AllowedValues:
      - true
      - false
    Description: >-
      Enable Lambda Vulnerability scanning.
    Default: false

Resources:
  LambdaExecutionRoleDatadogAgentlessAPICall:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
  # Retrieving secrets passed in via SecretsManager Arn
  DatadogAgentlessAPICall:
    Type: "Custom::DatadogAgentlessAPICall"
    Properties:
      ServiceToken: !GetAtt DatadogAgentlessAPICallFunction.Arn
      APIKey: !Ref DatadogApiKey
      APPKey: !Ref DatadogAppKey
      ApiURL: !Ref DatadogSite
      AccountId: !Ref AWS::AccountId
      Containers: !Ref Containers
      Hosts: !Ref Hosts
      Lambdas: !Ref Lambdas
  DatadogAgentlessAPICallFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "A function to call the Datadog Agentless API."
      Role: !GetAtt LambdaExecutionRoleDatadogAgentlessAPICall.Arn
      Handler: "index.handler"
      Runtime: "python3.8"
      Timeout: 30
      Code:
        ZipFile: |
          import boto3

          import json
          import logging
          import signal
          from urllib.request import build_opener, HTTPHandler, Request
          import urllib.parse

          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)

          API_CALL_SOURCE_HEADER_VALUE = "cfn-agentless-quick-start"

          def call_datadog_agentless_api(event, method):
              api_key = event['ResourceProperties']['APIKey']
              app_key = event['ResourceProperties']['APPKey']
              api_url = event['ResourceProperties']['ApiURL']
              account_id = event['ResourceProperties']['AccountId']
              containers = event['ResourceProperties']['Containers']
              hosts = event['ResourceProperties']['Hosts']
              lambdas = event['ResourceProperties']['Lambdas']

              # Make the url Request
              url = 'https://api.' + api_url + '/api/v2/agentless_scanning/accounts/aws'
              headers = {
                  'DD-API-KEY': api_key,
                  'DD-APPLICATION-KEY': app_key,
                  'Dd-Call-Source': API_CALL_SOURCE_HEADER_VALUE,
              }

              if method == "DELETE":
                  url = url + '/' + account_id
                  request = Request(url, headers=headers)
                  request.get_method = lambda: method
                  response = urllib.request.urlopen(request)
                  return response
              elif method == "POST":
                  values = {
                      "data": {
                          "id": account_id,
                          "type": "aws_scan_options",
                          "attributes": {
                              "vuln_containers_os": containers,
                              "vuln_host_os": hosts,
                              "lambda": lambdas,
                          }
                      }
                  }
                  data = json.dumps(values)
                  data = data.encode('utf-8')  # data should be bytes
                  request = Request(url, data=data, headers=headers)
                  request.add_header('Content-Type', 'application/vnd.api+json; charset=utf-8')
                  request.add_header('Content-Length', len(data))
                  request.get_method = lambda: method
                  response = urllib.request.urlopen(request)
                  return response
              else:
                  LOGGER.error('Unsupported HTTP method.')
                  return None

          def handler(event, context):
              '''Handle Lambda event from AWS'''
              try:
                  if event['RequestType'] == 'Create':
                      LOGGER.info('Received Create request.')
                      response = call_datadog_agentless_api(event, 'POST')
                      if response.getcode() == 200:
                          json_response = json.loads(response.read().decode("utf-8"))
                          send_response(event, context, "SUCCESS",
                                        {
                                            "Message": "Datadog AWS Agentless Scanning Integration created successfully.",
                                            "ExternalId": json_response["external_id"],
                                        })
                      else:
                          LOGGER.info('Failed - exception thrown during processing.')
                          send_response(event, context, "FAILED", {
                              "Message": "Http response: {}".format(response.msg)})

                  elif event['RequestType'] == 'Update':
                      LOGGER.info('Received Update request.')
                      send_response(event, context, "SUCCESS",
                                    {"Message": "Update not supported, no operation performed."})
                  elif event['RequestType'] == 'Delete':
                      LOGGER.info('Received Delete request.')
                      response = call_datadog_agentless_api(event, 'DELETE')

                      if response.getcode() == 200:
                          send_response(event, context, "SUCCESS",
                                        {
                                            "Message": "Datadog AWS Agentless Scanning Integration deleted successfully.",
                                        })
                      else:
                          LOGGER.info('Failed - exception thrown during processing.')
                          send_response(event, context, "FAILED", {
                              "Message": "Http response: {}".format(response.msg)})

                  else:
                      LOGGER.info('Failed - received unexpected request.')
                      send_response(event, context, "FAILED",
                                    {"Message": "Unexpected event received from CloudFormation"})
              except Exception as e:  # pylint: disable=W0702
                  LOGGER.info('Failed - exception thrown during processing.')
                  send_response(event, context, "FAILED", {
                      "Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
              '''Send a resource manipulation status response to CloudFormation'''
              response_body = json.dumps({
                  "Status": response_status,
                  "Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
                  "PhysicalResourceId": context.log_stream_name,
                  "StackId": event['StackId'],
                  "RequestId": event['RequestId'],
                  "LogicalResourceId": event['LogicalResourceId'],
                  "Data": response_data
              })
              formatted_response = response_body.encode("utf-8")

              LOGGER.info('ResponseURL: %s', event['ResponseURL'])
              LOGGER.info('ResponseBody: %s', response_body)

              opener = build_opener(HTTPHandler)
              request = Request(event['ResponseURL'], data=formatted_response)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(formatted_response))
              request.get_method = lambda: 'PUT'
              response = opener.open(request)
              LOGGER.info("Status code: %s", response.getcode())
              LOGGER.info("Status message: %s", response.msg)


          def timeout_handler(_signal, _frame):
              '''Handle SIGALRM'''
              raise Exception('Time exceeded')


          signal.signal(signal.SIGALRM, timeout_handler)